GIN_DIRECTORY:=${HOME}/.gin
LINT_CONFIG_DIRECTORY:=${GIN_DIRECTORY}/golangci-lint-config
LINT_CONFIG_FILE:=${GIN_DIRECTORY}/golangci-lint-config/.golangci.yml
LINT_CONFIG_REMOTE:=ssh://git@gitlab.databet.one:7999/infra/golangci-lint-config.git
TEST_RESULT_DIR:=test-results
TEST_PACKAGES:=./...
TEST_COVERAGE_OUT_PATH:=${TEST_RESULT_DIR}/cover.out
TEST_JUNIT_OUT_PATH:=${TEST_RESULT_DIR}/test-junit.xml

.PHONY: check-golang
check-golang:
	@which go > /dev/null 2>&1 || (echo "You're missing go executable"; exit 1)

.PHONY: check-golangci-lint
check-golangci-lint:
	@which golangci-lint > /dev/null 2>&1 || (echo "You're missing golangci-lint executable"; exit 1)

.PHONY: check-gotestsum
check-gotestsum:
	@which gotestsum > /dev/null 2>&1 || (echo "You're missing github.com/gotestyourself/gotestsum executable"; exit 1)

.PHONY: check-codegeneration
check-codegeneration:
	@go generate ./...
	@test $(shell git ls-files -mok --full-name '**/*.go' | xargs grep '^// Code generated .* DO NOT EDIT\.$$' | wc -l) -eq 0 || (echo "Codegeneration is not up to date! run \"go gonerate ./...\" and commit the result!"; exit 1)

.PHONY: check-git-version
check-git-version:
	$(eval GIT_EXPECTED_VERSION := "2.23")
	$(eval GIT_FULL_VERSION := $(shell git version | grep -Eo "([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+)"))
	@(echo required version ${GIT_EXPECTED_VERSION}; git --version) | sort -Vk3 | tail -1 | grep -v -q required || (printf "\033[0;31mWrong git version\nCurrent: ${GIT_FULL_VERSION}, expected: ^${GIT_EXPECTED_VERSION}\n"; exit 1)


.PHONY: install-linter
install-linter:
	go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

.PHONY: fetch-lint-config
fetch-lint-config:
ifneq (,$(wildcard ${LINT_CONFIG_DIRECTORY}))
	@echo Directory is not empty. Cleaning up
	@cd ${LINT_CONFIG_DIRECTORY} && git pull
else
	@git clone ${LINT_CONFIG_REMOTE} ${LINT_CONFIG_DIRECTORY} > /dev/null 2>&1
endif

.PHONY: build
build: check
	go build ./cmd/console -o callback-test-tool


.PHONY: check
check: check-git-version check-golang fetch-lint-config check-codegeneration

.PHONY: run-lint
run-lint:
	@golangci-lint run -c "${LINT_CONFIG_FILE}" --timeout=5m ./...

.PHONY: lint
lint: check-golangci-lint run-lint

.PHONY: get-codecov-out-path
get-codecov-out-path:
	@echo -n ${TEST_COVERAGE_OUT_PATH}

.PHONY: get-junit-out-path
get-junit-out-path:
	@echo -n ${TEST_JUNIT_OUT_PATH}

.PHONY: run-test-codecov
run-test-codecov:
	gotestsum --junitfile ${TEST_JUNIT_OUT_PATH} -- \
 		-timeout=5m -count=1 -coverprofile=${TEST_COVERAGE_OUT_PATH} -covermode=atomic -coverpkg=./internal/... ${TEST_PACKAGES}

.PHONY: test-codecov-mkdir
test-codecov-mkdir:
	@mkdir -p ${TEST_RESULT_DIR}

.PHONY: test-codecov
test-codecov: test-codecov-mkdir check-gotestsum run-test-codecov codecov-exclude-generated-files

.PHONY: cover-serve
cover-serve:
	go tool cover -html=${TEST_COVERAGE_OUT_PATH}

define find-generated-files
	find . -name '*.go' | xargs head -n1 | grep -B1 "Code generated by" | sed -n -e "s/^==> \.\/\(.*\) <==/\1/p"
endef

.PHONY: codecov-exclude-generated-files
codecov-exclude-generated-files:
	$(eval GENERATED_FILES_PATH := $(shell mktemp))
	$(eval TMP_EXCLUDED_PATH := $(shell mktemp))
	@$(find-generated-files) > ${GENERATED_FILES_PATH}
	@grep -vf ${GENERATED_FILES_PATH} ${TEST_COVERAGE_OUT_PATH} > ${TMP_EXCLUDED_PATH}
	@rm ${GENERATED_FILES_PATH}
	@mv ${TMP_EXCLUDED_PATH} ${TEST_COVERAGE_OUT_PATH}

.PHONY: run-test-with-coverage
run-test-with-coverage: test-codecov get-test-coverage

.PHONY: get-test-coverage
get-test-coverage:
	$(eval CODE_COVERAGE := $(shell go tool cover -func=${TEST_COVERAGE_OUT_PATH} | tail -n1 | grep -oE "[0-9]{1,2}.[0-9]\%"))
	@echo "Test code coverage: ${CODE_COVERAGE}"
